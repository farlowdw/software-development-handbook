---
title: Data Structures Overview
hide_title: false
sidebar_label: Introduction
description: Overview of various data structures
draft: false
tags: 
  - Overview
  - Data Structures
keywords: 
  - data structures
hide_table_of_contents: false
toc_min_heading_level: 2
toc_max_heading_level: 5
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Link from '@docusaurus/Link';
import GitHubIcon from '@site/src/components/Icons/GitHubIcon';
import StackOverflowIcon from '@site/src/components/Icons/StackOverflowIcon';
import PythonIcon from '@site/src/components/Icons/PythonIcon';
import BibRef from '@site/src/components/BibRef';

import WorstCaseComplexities from '@site/docs/_Partials/time-and-space-complexities/all-worst-case.md'
import AverageCaseComplexities from '@site/docs/_Partials/time-and-space-complexities/all-average-case.md'
import ArraySortingAlgorithmsComplexities from '@site/docs/_Partials/time-and-space-complexities/all-array-sorting-algorithms.md'

## Time and Space Complexity Overviews

Click on a tab below to see the worst or average case time complexities for access, search, insertion, and deletion operations for common data structures. The worst case tab includes space complexity details for each data structure. The last tab includes details about the best, average, and worst case time complexities for various array sorting algorithms as well as a column with space complexity details.

<Tabs>
<TabItem value='tc-worst-case-data-structures' label='Worst Case'>

<WorstCaseComplexities />

</TabItem>
<TabItem value='tc-average-case-data-structures' label='Average Case'>

<AverageCaseComplexities />

</TabItem>
<TabItem value='tc-array-sorting-algorithms' label='Array Sorting Algorithms'>

<ArraySortingAlgorithmsComplexities />

</TabItem>
</Tabs>

## What is a data structure?

A *data structure*, as its name implies, is a way of structuring data. Since we are dealing with computers, we are ultimately talking about a way of specifically structuring data inside [random-access memory](https://en.wikipedia.org/wiki/Random-access_memory) (RAM). As the [Wiki article](https://en.wikipedia.org/wiki/Data_structure) notes:

> In computer science, a data structure is a data organization, management, and storage format that is usually chosen for efficient access to data. More precisely, a data structure is a collection of data values, the relationships among them, and the functions or operations that can be applied to the data (i.e., it is an algebraic structure about data).

## Abstract data types (ADTs)

The [Wiki page](https://en.wikipedia.org/wiki/Abstract_data_type#Common_ADTs) for ADTs lists the following as some of the most common:

:::info Finding the source code for Python's built-in functions and types

As [one helpful Stack Overflow post](https://stackoverflow.com/a/47371323/5209533) notes, you can generally find the source code for Python's built-in functions and built-in types at the following locations:

- [Built-in functions source](https://github.com/python/cpython/blob/main/Python/bltinmodule.c)
  + https://github.com/python/cpython/blob/main/Python/bltinmodule.c
- [Built-in objects source](https://github.com/python/cpython/tree/main/Objects)
  + https://github.com/python/cpython/tree/main/Objects

:::

| ADT | Description and Python implementation reference(s) |
| :-- | :-- |
| [String](https://en.wikipedia.org/wiki/String_(computer_science)) | **TLDR:** `''` (string literal results in an `str` object) &nbsp; <Link to='https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Objects/unicodeobject.c'><GitHubIcon fontSize='small' color='inherit' /></Link> &nbsp; <Link to='https://stackoverflow.com/questions/3820506/location-of-python-string-class-in-the-source-code#comment81541250_3820526'><StackOverflowIcon fontSize='small' /></Link> <br /><br />A string is a sequence of characters. From [the Python docs](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str): "Textual data in Python is handled with [`str`](https://docs.python.org/3/library/stdtypes.html#str) objects, or *strings*. Strings are immutable [sequences](https://docs.python.org/3/library/stdtypes.html#typesseq) of Unicode code points." |
| [List](https://en.wikipedia.org/wiki/List_(abstract_data_type)) | **TLDR:** `[]` (list literal results in a `list` sequence type) &nbsp; <Link to='https://docs.python.org/3/library/stdtypes.html#list'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Objects/listobject.c'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/questions/8608587/finding-the-source-code-for-built-in-python-functions#comment96371642_47371323'><StackOverflowIcon /></Link> <br /><br />A list or *sequence* is an ADT that represents a finite number of ordered values, where the same value may occur more than once. Python's default [`list`](https://docs.python.org/3/library/stdtypes.html#list) type is a [dynamic array](https://en.wikipedia.org/wiki/Dynamic_array) that allows efficient resizing for dynamic data storage as opposed to an [array](https://en.wikipedia.org/wiki/Array_(data_type)) data structure that has a fixed size.<br /><br />In Python, [the docs](https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str) indicate there are three basic sequence types: lists, tuples, and range objects ([`list`](https://docs.python.org/3/library/stdtypes.html#list), [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple), [`range`](https://docs.python.org/3/library/stdtypes.html#range)). There are additional sequence types tailored for processing of [binary data](https://docs.python.org/3/library/stdtypes.html#binaryseq) (i.e., [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes), [`bytearray`](https://docs.python.org/3/library/stdtypes.html#bytearray), and [`memoryview`](https://docs.python.org/3/library/stdtypes.html#memoryview)) and [text strings](https://docs.python.org/3/library/stdtypes.html#textseq) (i.e., [`str`](https://docs.python.org/3/library/stdtypes.html#str)).<br /><br />Python discusses [common sequence operations](https://docs.python.org/3/library/stdtypes.html#common-sequence-operations) and provides a table of operations supported by most sequences types. They even provide an abstract base class (ABC) to make it easier to correctly implement the commonly supported sequence operations on custom sequence types: [`collections.abc.Sequence`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence). <br /><br />Finally, it's important to note that a list can be implemented in various ways, not just with an array or a dynamic array. A linked list is a popular implementation of the List ADT when insertions and deletions are frequent and they predominately occur at the beginning of the list. If, however, direct access is important, as is often the case, then an array will likely be a more suitable implementation than a linked list. Python does not have a `LinkedList` class; instead, Python provides a [`deque`](https://docs.python.org/3/library/collections.html#collections.deque) which is implemented as a doubly-linked list under the hood. |
| [Queue](https://en.wikipedia.org/wiki/Queue_(abstract_data_type)) | **TLDR:** `collections.deque` &nbsp; <Link to='https://docs.python.org/3/library/collections.html#collections.deque'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/8f4f77364750d0ceec47157e8920983e3f41651f/Modules/_collectionsmodule.c#L71'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/6257048/5209533'><StackOverflowIcon /></Link> <br /><br />A queue is a collection of entities that are maintained in a sequence and can be modified by the addition of entities at one end of the sequence (enqueue) and the removal of entities from the other end of the sequence (dequeue). These operations make a queue "FIFO" or *first-in-first-out*.<br /><br />Interestingly, Python has a [`queue`](https://docs.python.org/3/library/queue.html#module-queue) module, but it is unlikely to be what you want if what you're primarily interested in is a data structure that allows $O(1)$ insertions and deletions (i.e., enqueuing from the right and dequeuing from the left). As [this post](https://stackoverflow.com/a/717261/5209533) notes, "`queue.Queue` is intended for allowing different threads to communicate using queued messages/data, whereas `collections.deque` is simply intended as a data structure." Hence, the `queue` module is primarily a tool for using [thread-safe queues](https://realpython.com/queue-in-python/#using-thread-safe-queues).<br /><br />If you don't care about concurrency or threading and you don't need the thread-safety features provided by the `queue` module, then `deque` is the clear choice. It doesn't include the overhead associated with thread-safe operations like the `queue` module does. The [Python docs for `queue`](https://docs.python.org/3/library/queue.html#module-queue) even suggest `deque` as an alternative for this very reason: "[`collections.deque`](https://docs.python.org/3/library/collections.html#collections.deque) is an alternative implementation of unbounded queues with fast atomic [`append()`](https://docs.python.org/3/library/collections.html#collections.deque.append) and [`popleft()`](https://docs.python.org/3/library/collections.html#collections.deque.popleft) operations that do not require locking and also support indexing." |
| [Double-ended queue](https://en.wikipedia.org/wiki/Double-ended_queue) | **TLDR:** `collections.deque` &nbsp; <Link to='https://docs.python.org/3/library/collections.html#collections.deque'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/8f4f77364750d0ceec47157e8920983e3f41651f/Modules/_collectionsmodule.c#L71'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/6257048/5209533'><StackOverflowIcon /></Link> <br /><br />A double-ended queue is an ADT that generalizes a queue, for which elements can be added to or removed from either the front (head) or back (tail). |
| [Priority queue](https://en.wikipedia.org/wiki/Priority_queue) | **TLDR:** `[]` or `heapify(your_list)` (requires `heapq` module) &nbsp; <Link to='https://docs.python.org/3/library/heapq.html#module-heapq'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Lib/heapq.py'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/19979723/5209533'><StackOverflowIcon /></Link> <br /><br />A priority queue is an ADT similar to a regular queue where each element in the queue has an associated *priority*. Elements are dequeued from the priority queue based on their associated value, with higher priority elements being dequeued before lower priority elements. <br /><br />To ensure these ADT-defining operations are executed efficiently for priority queues, implementations of priority queues often rely on a [heap](https://en.wikipedia.org/wiki/Heap_(data_structure)) data structure even though another method might be to use an [unordered array](https://www.cs.cmu.edu/~rdriley/121/notes/heaps.html#21-pq-with-an-array). A heap is a tree-based data structure that satisfies the heap property: "In a *max heap*, for any given node C, if P is a parent node of C, then the *key* (the *value*) of P is greater than or equal to the key of C. In a *min heap*, the key of P is less than or equal to the key of C." <br /><br />The Python docs for `heapq` note the pop method returns the smallest item, not the largest, meaning Python's heap implementation is that of a *min heap*, as described above. If, however, a *max heap* is needed, then items for the min heap can be multiplied by `-1` to simulate the behavior of a max heap (but be sure to multiply an item by `-1` whenever you push or pop an item from the heap!). <br /><br />It's probably worth mentioning that Python does have a [`queue.PriorityQueue`](https://docs.python.org/3/library/queue.html#queue.PriorityQueue) class, but this should be avoided unless you're dealing with concurrency and worried about thread safety (for reasons remarked on above when discussing the Queue ADT). Using the [`heapq`](https://docs.python.org/3/library/heapq.html#module-heapq) module provides the same data management benefits without the thread safety overhead. |
| [Double-ended priority queue](https://en.wikipedia.org/wiki/Double-ended_priority_queue) | **TLDR:** No built-in support (but consider [`depq`](https://pypi.org/project/depq/) on PyPi) &nbsp; <Link to='https://docs.python.org/3/library/heapq.html#module-heapq'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/3.12/Lib/heapq.py'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/1068706/5209533'><StackOverflowIcon /></Link> <br /><br />There's no nice reference/answer for a good Python implementation of the double-ended priority queue (DEPQ) ADT. It's tricky (the [Wiki page](https://en.wikipedia.org/wiki/Double-ended_priority_queue) is illustrative as to why this is the case), but the [`depq`](https://github.com/ofek/depq) package [on PyPi](https://pypi.org/project/depq/) is probably worth checking out. It might also be worth trying to implement this ADT yourself! <br /><br />[Min-max heaps](https://en.wikipedia.org/wiki/Min-max_heap) may prove fruitful if you try to implement this ADT yourself. There's [an article](https://www.cs.otago.ac.nz/staffpriv/mike/Papers/MinMaxHeaps/MinMaxHeaps.pdf) that discusses min-max heaps and generalized priority queues that may be helpful as a starting point. There's also a detailed discussion of DEPQs in <BibRef id='DM2018' pages='pp. 97-114'> </BibRef> where special attention is paid to using symmetric min-max heaps to implement DEPQs. Whatever way you choose, this is not a straightforward ADT to try to implement. |
| [Stack](https://en.wikipedia.org/wiki/Stack_(abstract_data_type)) | **TLDR:** `[]` (list literal results in a `list` sequence type that can easily be used as a stack) &nbsp; <Link to='https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Objects/listobject.c'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/4688885/5209533'><StackOverflowIcon /></Link> <br /><br />A stack is an ADT that serves as a collection of elements with two main operations: 1) push, which adds an element to the collection, and 2) pop, which removes the most recently added element. The Stack ADT is cleanly implemented in Python by simply using a list. As [the docs note](https://docs.python.org/3/tutorial/datastructures.html#using-lists-as-stacks): "The list methods make it very easy to use a list as a stack, where the last element added is the first element retrieved ('last-in, first-out'). To add an item to the top of the stack, use `append()`. To retrieve an item from the top of the stack, `use pop()` without an explicit index." Sure, it's *possible* to implement the Stack ADT using a linked list or something else, but the list is the preferred way for most use cases. |
| [Set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) | **TLDR:** `set()` &nbsp; <Link to='https://docs.python.org/3/library/stdtypes.html#set-types-set-frozenset'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Objects/setobject.c'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/3949350/5209533'><StackOverflowIcon /></Link> <br /><br />A set is an ADT that can store unique values, without any particular order. Python's `set` is a hash table-based implementation of the Set ADT. |
| [Multiset](https://en.wikipedia.org/wiki/Multiset) | **TLDR:** `collections.Counter` &nbsp; <Link to='https://docs.python.org/3/library/collections.html#counter-objects'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/0250de48199552cdaed5a4fe44b3f9cdb5325363/Lib/collections/__init__.py#L497'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/questions/17346905/is-there-a-python-equivalent-for-c-multisetint'><StackOverflowIcon /></Link> <br /><br />A multiset (also known as a "bag") is a modification of the concept of a set that, unlike a set, allows for multiple instances for each of its elements. The number of instances given for each element is called the multiplicity of that element in the multiset. Python does not have a built-in implementation of the Multiset ADT, but [it's possible to use `Counter` instances as multisets](https://realpython.com/python-counter/#using-counter-instances-as-multisets). Specifically, the keys in a `Counter` instance are unique (so they're equivalent to a set) and the counts hold the multiplicity or the number of instances of each element. |
| [Map](https://en.wikipedia.org/wiki/Associative_array) | **TLDR:** `{}` (dictionary literal results in a `dict` object) &nbsp; <Link to='https://docs.python.org/3/library/stdtypes.html#mapping-types-dict'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Objects/dictobject.c'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/56098068/5209533'><StackOverflowIcon /></Link> <br /><br />A map (also called an associative array, symbol table, dictionary, etc.) is an ADT that stores a collection of (key, value) pairs, such that each possible key appears at most once in the collection. [`dict`](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict) is a mapping type in Pyton that accomplishes exactly this: "A mapping object maps hashable values to arbitrary objects. Mappings are mutable objects. There is currently only one standard mapping type, the dictionary." |
| [Multimap](https://en.wikipedia.org/wiki/Multimap) | **TLDR:** `collections.defaultdict(list OR set)` &nbsp; <Link to='https://docs.python.org/3/library/collections.html#defaultdict-objects'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/47133d8d869c94c4d1f340b5481cc3f2cdc7d68b/Modules/_collectionsmodule.c#L1931'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/q/1731971/5209533'><StackOverflowIcon /></Link> <br /><br />A multimap is a generalization of a map or associative array ADT in which more than one value may be associated with and returned for a given key. Both map and multimap are particular cases of containers. Often the multimap is implemented as a map with lists or sets as the map values, which is exactly what `defaultdict(list OR set)` accomplishes (respectively). |
| [Collection](https://en.wikipedia.org/wiki/Collection_(abstract_data_type)) | **TLDR:** `collections` &nbsp; <Link to='https://docs.python.org/3/library/collections.html#'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Lib/collections/__init__.py'><GitHubIcon fontSize='small' /></Link><br /><br /> A collection is a grouping of some variable number of data items that have some shared significance to the problem being solved and need to be operated upon together in some controlled fashion. Python's `collections` module implements specialized container datatypes that provide alternatives to Python's general purpose built-in containers, namely `dict`, `list`, `set`, and `tuple`. The `collections` module is basically a [buffet of specialized container data types](https://realpython.com/python-collections-module/). |
| [Container](https://en.wikipedia.org/wiki/Container_(abstract_data_type)) | **TLDR:** `dict`, `list`, `set`, `tuple`, `collections` (module) &nbsp; <Link to='https://docs.python.org/3/library/collections.html#module-collections'><PythonIcon /></Link> &nbsp; <Link to='https://github.com/python/cpython/blob/main/Lib/collections/__init__.py'><GitHubIcon fontSize='small' /></Link> &nbsp; <Link to='https://stackoverflow.com/a/11576019/5209533'><StackOverflowIcon /></Link> <br /><br />A container is a class or a data structure whose instances are collections of other objects. In other words, they store objects in an organized way that follows specific access rules. In Python, examples of built-in containers include `dict`, `list`, `set`, and `tuple`, but more container types are available in the [`collections`](https://docs.python.org/3/library/collections.html#) module. |
| [Tree](https://en.wikipedia.org/wiki/Tree_(data_structure)) | **TLDR:** No built-in support &nbsp; <Link to='https://stackoverflow.com/a/2358075/5209533'><StackOverflowIcon /></Link> <br /><br /> A tree is a hierarchical structure of nodes, where each node has a value and a list of references to other nodes (children). Trees are not directly implemented in Python but can be built most notably by using classes. |
| [Graph](https://en.wikipedia.org/wiki/Graph_(abstract_data_type)) | **TLDR:** No built-in support &nbsp; <Link to='https://www.python.org/doc/essays/graphs/'><PythonIcon /></Link> &nbsp; <Link to='https://stackoverflow.com/a/67237532/5209533'><StackOverflowIcon /></Link> <br /><br /> A graph represents a set of connections (edges) between nodes (vertices). There's no direct built-in Python implementation, but graphs can be represented in various ways, namely [edge lists](https://en.wikipedia.org/wiki/Edge_list), [adjacency lists](https://en.wikipedia.org/wiki/Adjacency_list), or [adjacency matrices](https://en.wikipedia.org/wiki/Adjacency_matrix) (among other representations). |
