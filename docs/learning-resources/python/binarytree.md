---
title: Using the binarytree Package in Python
hide_title: false
sidebar_label: binarytree (Python package)
description: Explorations of the binarytree package for Python
draft: false
tags: 
  - Python
  - binarytree
  - Interview Crash Course
  - Sandbox
keywords: 
  - interview
  - crash course
  - sandbox
hide_table_of_contents: false
toc_min_heading_level: 2
toc_max_heading_level: 5
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import LC from '@site/src/components/LC';

:::info Source Code 

This page concerns usage of the [`binarytree`](https://pypi.org/project/binarytree/) package for Python. From the [documentation home page](https://binarytree.readthedocs.io/en/main/):

> **Binarytree** is Python library which lets you generate, visualize, inspect and manipulate [binary trees](https://en.wikipedia.org/wiki/Binary_tree). Skip the tedious work of setting up test data, and dive straight into practising algorithms. [Heaps](https://en.wikipedia.org/wiki/Heap_(data_structure)) and [binary search trees](https://en.wikipedia.org/wiki/Binary_search_tree) are also supported. Self-balancing search trees like [red-black](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree) or [AVL](https://en.wikipedia.org/wiki/AVL_tree) will be added in the future.

It notes Python 3.7+ as a requirement for use of the package. The source code for the package may be found either on [the package's GitHub page](https://github.com/joowani/binarytree) or [its own documentation site](https://binarytree.readthedocs.io/en/main/_modules/binarytree.html#Node).

:::

## Observations

### LeetCode

Arguably one of the biggest selling points for the `binarytree` package is its ability to let you reproduce binary trees encountered when solving LeetCode problems. For example, consider <LC id='1026' type='long' ></LC>. We are told the definition for a binary tree node is as follows (this definition holds true for pretty much all LeetCode problems involving binary trees, except in some cases maybe `val` does not have a default value, `left` and `right` may not default to `None`, etc., but the structure is the same nonetheless):

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
```

And the second example in the problem statement includes the following depiction of a binary tree:

<div align='center' class='centeredImageDiv'>
  <img width='250px' src={require('@site/static/img/learning-resources/python/binarytree/lc1026-example.png').default} />
</div>

How could we reproduce this tree using our own code? We could create our own `Node` or `TreeNode` class and *build* it ourselves by establishing the root and then linking together all nodes, but this becomes quite cumbersome as the tree grows (imagine encountering a test case for a tree with over a thousand nodes). Fortunately, there's a much better alternative for building such trees, namely using the `binarytree` package.

The problem specifies as input the following for the tree above:

```
root = [1,null,2,null,0,3]
```

Can we somehow use this information to build the tree with the `binarytree` package? Yes! As the site documentation notes for the [`build2`](#api-build2) function:

> Binarytree supports another representation which is more compact but without the indexing properties (this method is often used in Leetcode).

Replace all instances of `null` with `None` for the root provided in the LeetCode input, and then use `build2` to build the tree. We can then print the tree to see how it represents the image taken from LeetCode above:

```python title="Input"
from binarytree import build2

lc_tree = [1,None,2,None,0,3]
print(build2(lc_tree))
```

```a title="Output"
1
 \
  2__
     \
      0
     /
    3
```

A less compact way of building the tree above would be to use [`build`](#api-build), where we need to provide the list representation of the binary tree, where the list of node values is generated by index for a left-to-right breadth-first order starting from the root:

```python title="Input"
from binarytree import build

lc_tree = [1,None,2,None,None,None,0,None,None,None,None,None,None,3]
print(build(lc_tree))
```

```a title="Output"
1
 \
  2__
     \
      0
     /
    3
```

The easiest way to tell the difference between `build` and `build2` is how parent nodes play a role. For `build2`, starting with `[1,None,2]` indicates the left child of the root does not exist; thus, this cannot be the parent of any subsequent node. When we provide another value in our list, namely resulting in `[1,None,2,None]`, this means `None` becomes the left child of `2` since `2` can actually be a parent. Providing `0` simply means `0` is now the right child of `2`. Continuing on, the only legitimate parent now is `0`, which means providing a value of `3` next results in `3` being the left child of `1`. Hence, we only have to provide `[1,None,2,None,0,3]` to fully specify the tree.

The package documentation gives a more algebraic explanation for `binarytree.build2`:

> List of node values like those for `binarytree.build()`, but with a slightly different representation which associates two adjacent child values with the first parent value that has not been associated yet. This representation does not provide the same indexing properties where if a node is at index `i`, its left child is always at `2i + 1`, right child at `2i + 2`, and parent at `floor((i - 1) / 2)`, but it allows for more compact lists as it does not hold `None`s between nodes in each level.

This is how LeetCode specifies its binary trees as input and allows for you to easily play around with possible tests cases.



## Overview 

### Representing a node

Binarytree uses the following class to represent a node:

```python
class Node:
    def __init__(self, value, left=None, right=None):
        self.value = value  # The node value (float/int/str)
        self.left = left    # Left child
        self.right = right  # Right child
```

Behind the scenes, the following assignment is made:

```python
self.value = self.val = value
```

This makes it possible to comply completely with how LeetCode usually has its binary trees defined.

### Generate and pretty-print various types of binary trees

### Random binary tree 

```python title="Input"
from binarytree import tree

# Generate a random binary tree and return its root node.
my_tree = tree(height=3, is_perfect=False)
print(my_tree)
```

```a title="Output"
       ______7_____
      /            \
    _9___        ___12
   /     \      /     \
  14     _10   4       2
 /      /       \
6      13        11
```

Note that parameters of `height=3` and `is_perfect=False` were provided. The [API specification](https://binarytree.readthedocs.io/en/main/specs.html#function-binarytree-tree) for `binarytree.tree` provides the following function signature:

```a title="binarytree.tree (function signature)"
binarytree.tree(
  height: int = 3, 
  is_perfect: bool = False, 
  letters: bool = False
) → Optional[binarytree.Node]
```


## API specification

- [`binarytree.Node`](#api-node)
- [`binarytree.build()`](#api-build)
- [`binarytree.build2()`](#api-build2)
- [`binarytree.tree()`](#api-tree)
- [`binarytree.bst()`](#api-bst)
- [`binarytree.heap()`](#api-heap)
- [`binarytree.get_index()`](#api-get-index)
- [`binarytree.get_parent()`](#api-get-parent)

### binarytree.Node {#api-node}

```a title="Signature"
binarytree.Node(
  value: Any, 
  left: Optional[Node] = None, 
  right: Optional[Node] = None
)
```

Represents a binary tree node.

This class provides methods and properties for managing the current node, and the binary tree in which the node is the root. When a docstring in this class mentions “binary tree”, it is referring to the current node and its descendants. The following parameters may be passed to a new instance of `Node`:

- **`value`** `(float | int | str)` &#8212; Node value (must be a float/int/str).
- **`left`** `(binarytree.Node | None)` &#8212; Left child node (default: `None`).
- **`right`** `(binarytree.Node | None)` &#8212; Right child node (default: `None`).

The following exceptions may be raised when creating a new instance of the `Node` class:

- [`binarytree.exceptions.NodeTypeError`](#ex-node-type-error) &#8212; If left or right child node is not an instance of [`binarytree.Node`](#api-node).
- [`binarytree.exceptions.NodeValueError`](#ex-node-value-error) &#8212; If node value is invalid.

#### `__delitem__` {#node-delitem}

Remove the node (or subtree) at the given [`level-order`](https://en.wikipedia.org/wiki/Tree_traversal#Breadth-first_search) index.

- An exception is raised if the target node is missing.
- The descendants of the target node (if any) are also removed.
- Root node (current node) cannot be deleted.

##### Parameters

`index (int)` &#8212; Level-order index of the node.

##### Raises

- [`binarytree.exceptions.NodeNotFoundError`](#ex-node-not-found-error) &#8212; If the target node or its parent is missing.
- [`binarytree.exceptions.NodeModifyError`](#ex-node-modify-error) &#8212; If user attempts to delete the root node (current node).

##### Examples

<Tabs>
<TabItem value='input' label='Input'>

```python title='Input'
from binarytree import Node

root = Node(1)          # index: 0, value: 1
root.left = Node(2)     # index: 1, value: 2
root.right = Node(3)    # index: 2, value: 3

del root[0]
```

</TabItem>
<TabItem value='output' label='Output'>

```a title='Output'
# highlight-error-start
Traceback (most recent call last):
...
binarytree.exceptions.NodeModifyError: cannot delete the root node
# highlight-error-end
```

</TabItem>
</Tabs>

<Tabs>
<TabItem value='input' label='Input'>

```python title='Input'
from binarytree import Node

root = Node(1)          # index: 0, value: 1
root.left = Node(2)     # index: 1, value: 2
root.right = Node(3)    # index: 2, value: 3

del root[2]

print(root[2])
```

</TabItem>
<TabItem value='output' label='Output'>

```a title='Output'
# highlight-error-start
Traceback (most recent call last):
...
binarytree.exceptions.NodeNotFoundError: node missing at index 2
# highlight-error-end
```

</TabItem>
</Tabs>

### binarytree.build() {#api-build}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.build2() {#api-build2}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.tree() {#api-tree}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.bst() {#api-bst}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.heap() {#api-heap}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.get_index() {#api-get-index}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples



### binarytree.get_parent() {#api-get-parent}

#### Signature

```a title="Signature"
tbd
```

#### Parameters

#### Returns

#### Return type

#### Raises

#### Examples





## Exceptions

Below are various exceptions

```
binarytree.exceptions.<ExceptionType>
```

raised by `binarytree`:

### BinaryTreeError {#ex-binary-tree-error}

Base (catch-all) binarytree exception.

### NodeIndexError {#ex-node-index-error}

Node index was invalid.

### NodeModifyError {#ex-node-modify-error}

User tried to overwrite or delete the root node.

### NodeNotFoundError {#ex-node-not-found-error}

Node was missing from the binary tree.

### NodeReferenceError {#ex-node-reference-error}

Node reference was invalid (e.g. cyclic reference).

### NodeTypeError {#ex-node-type-error}

Node was not an instance of `binarytree.Node`.

### NodeValueError {#ex-node-value-error}

Node value was not a number (e.g. float, int, str).

### TreeHeightError {#ex-tree-height-error}

Tree height was invalid.

## Graphviz and Jupyter Notebook

