```python
class Solution:
    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        new_head = head.next
        prev = ListNode(-1)
        curr = head
        
        while curr and curr.next:
            next_node = curr.next
            next_next_node = curr.next.next
            next_node.next = curr
            curr.next = next_next_node
            prev.next = next_node
            prev = curr
            curr = next_next_node
            
        return new_head
```

This is an interestingly tough problem, where reversals are done in a pairwise fashion. As usual with linked list problems, it's most helpful if you name variables appropriately and *draw* what you intend for the logic to be if you can. One of the trickier parts of this problem is ensuring that swapped nodes point to subsequently swapped nodes; that is, for

```
1 -> 2 -> 3 -> 4
```

it's easy to make the mistake of the swaps ending with the following (i.e., `1` is never adjusted to point to `4` once `3` and `4` have been swapped):

```
2 -> 1 -> 3 -> None
     4 -> 3
```

Effective usage of the `prev` pointer above eliminates this problem.